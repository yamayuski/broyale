# Entity Component System (ECS) 概要と設計ガイド

このドキュメントは、ゲームエンジン設計における Entity Component
System（ECS）の概念、なぜ必要か、各設計選択がどのように紐づくかをまとめたものです。実装例は別途提示しますが、まずは設計上の理解とトレードオフを整理します。

## 1. ECS の目的（なぜ必要か）

- データと振る舞いを分離して、柔軟な組み合わせ（コンポジション）でエンティティの振る舞いを構成するため。
- 高速なループ処理（特に大量のエンティティ）を可能にするため、データレイアウト／アクセスパターンを最適化するため。
- 継承ベースのクラス階層で生じる複雑さ・爆発的な組み合わせ問題を避けるため。

## 2. コア概念と役割（何が必要か）

- Entity
  - ID（通常は整数）だけを持つ軽量な参照。
  - データや振る舞いを直接持たない「識別子」。
  - 役割：エンティティのライフサイクル管理（生成/破棄）と、コンポーネントの集合を参照するためのキーになる。

- Component
  - 純粋データ（例：Position, Velocity, Health）。
  - 振る舞い（ロジック）は持たない。
  - 役割：シンプルなデータコンテナにより、メモリ配置や更新ループの最適化を可能にする。

- System
  - ある種のコンポーネント組合せ（Query）に対して振る舞いを実行するロジック。
  - 役割：クエリ結果を効率的に走査し、ゲームロジック（物理、レンダリング、AI
    等）を実行する。

- World / Registry / Engine
  - エンティティ、コンポーネントストレージ、システムを管理するコア。
  - 役割：ライフサイクル管理、クエリ実行、システム更新のオーケストレーション。

## 3. データ配置（重要な設計選択）

ECS の性能や実装複雑度は、主にデータの配置（how components are
stored）によって決まります。代表的な選択肢と特徴：

- Map（ハッシュ／連想配列）ベース
  - 実装：コンポーネント種別ごとに Map<Entity, Component> を持つ
  - 長所：実装が単純で理解しやすい。追加削除が簡単。
  - 短所：メモリアクセスが散らばりやすく、キャッシュ効率は低め。大量エンティティでは遅くなる。
  - 向く用途：プロトタイプ、小〜中規模プロジェクト、開発のしやすさ重視。

- Archetype（構成ごとに密に格納）
  - 実装：同じコンポーネント集合（アーキタイプ）を持つエンティティを列で格納し、各コンポーネントはSoAまたはAoSで管理。
  - 長所：同一アーキタイプ内はメモリが密で走査が高速。キャッシュフレンドリー。
  - 短所：実装が複雑（コンポーネント追加/削除でアーキタイプ移動が必要）。柔軟性と実装コストのトレードオフ。
  - 向く用途：大規模ゲーム、性能が重要な場面。

- SoA（Structure of Arrays）
  - 実装：各コンポーネントのフィールドごとに連続配列で保持（例えば positionsX[],
    positionsY[]）。
  - 長所：数値演算の最適化、SIMD 利用に適する。
  - 短所：柔軟性が少なく実装が複雑。型ごとの扱いが煩雑。

設計上の第一ステップは「必要なスケール」を見極め、Map
ベースで始めてボトルネックが出たら Archetype/SoA に移行する方針が現実的。

## 4. クエリ（Query）の設計と実行方法

System
は通常、コンポーネントの組合せにマッチするエンティティ集合を取得して処理します。クエリ設計の要点：

- クエリ種類
  - all（すべての指定コンポーネントを持つ）
  - any（いずれかを持つ）
  - none（指定コンポーネントを持たない）
  - 複合（all + none など）
- 実行戦略
  - Map ベース：最小サイズのコンポーネント Map
    を基準に走査し、他コンポーネントの有無をチェックする（効率的）。
  - Archetype：アーキタイプ集合を列挙して各アーキタイプ配列を直列に走査する（高効率）。
- インクリメンタル更新
  - クエリキャッシュ（どのアーキタイプがクエリと一致するか）や変更通知（component
    add/remove）で、毎フレームの検索コストを減らす。

## 5. コンポーネント設計上の考え方

- データはできるだけシンプルに（プリミティブや小さな構造体）。
- 状態と副作用（例：リソース参照の自動解放）は World/Systems 側で扱う。
- タグコンポーネント（データをほぼ持たない、存在自体が意味を持つ）を使う：例
  EnemyTag, StaticTag。
- コンポーネントの関係
  - コンポジション（推奨）：複数コンポーネントを組合せて振る舞いを表現。
  - 継承（避ける）：複雑性が増すため ECS では一般に使わない。
- 参照の扱い
  - Entity ID を使う（軽量で独立）
  - 直接オブジェクト参照は GC とライフサイクル管理で問題になるため注意

## 6. ライフサイクルとイベント

- 主要イベント
  - Entity created / destroyed
  - Component added / removed
  - Component updated（場合による）
- 使いどころ
  - 初期化（OnAdd）やクリーンアップ（OnRemove）処理のフックを提供すると便利。
  - システムはこれらのイベントを購読して内部キャッシュを保つことができる。
- 削除戦略
  - 即時削除 vs マーク＆後処理：フレーム中の参照安全性の観点から「削除マーク →
    フレーム終端で実際に除去」が安全。

## 7. エンティティ間の関係（親子・参照）

- 親子（階層）
  - Parent コンポーネント（親の Entity ID）と Children（配列または索引）で実装。
  - トランスフォームの継承などに使うが、ループや更新順（親→子）に注意。
- 参照の整合性
  - 参照先のエンティティが削除される可能性を想定し、弱参照（ID）＋存在チェックを行うか、削除通知で参照をクリアする。

## 8. 性能最適化の観点

- イテレーション順序を固定してキャッシュ局所性を高める（アーキタイプの利点）。
- 分岐（if）を減らす：クエリで対象を絞っておく。
- メモリ割当／GC の削減：コンポーネントプール（再利用）を導入。
- SIMD /
  並列化：読み取り専用のシステムは並列化しやすい。書き込み依存がある場合は同期が必要。
- プロファイリングでボトルネックを特定し、マイクロ最適化を行う。

## 9. TypeScript での型安全性設計（実用上の注意）

- コンポーネント識別に「コンストラクタ関数」をキーとして使う（実行時に型が消えるため）。
- ジェネリクス／型マップを用いて getComponent の戻り型を改善する。
- ランタイムと型システムの乖離に注意：型は静的保証に役立つが、実行時には存在チェックが必要。
- 例：Map ベース実装では Map<Constructor, Map<entity, instance>> の構造を取る。

## 10. シリアライズ／ネットワーク設計（分散／保存）

- 永続化用シリアライズ：コンポーネント単位でのシリアライズ/デシリアライズを用意する。
- ネットワーク同期
  - 標準的なアプローチ：状態差分（delta）を送る。重要なのはコンポーネントごとの変更検出。
  - 権限モデル：サーバーがオーソリティ（authoritative）になることが多い。クライアントは入力のみ送信。
- 安定
  ID：セーブデータやマッチングで必要。ランタイムIDとは別に永続IDを用意する場合もある。

## 11. テスト・デバッグ

- 可視化ツール：コンポーネントの存在表、アーキタイプ分布、クエリヒット数などを出力する。
- ロギングと断言：System の前後で invariants（不変条件）をチェック。
- ユニットテスト：World のライフサイクル（create/destroy/add/remove）や System
  のロジックは小さく分けてテスト可能にする。

## 12. よくある落とし穴と回避策

- コンポーネントにロジックを混ぜる（データとロジックの混在）：ロジックは System
  側に置く。
- 実行時に頻繁に Map を生成したり大量の一時オブジェクトを作る：GC
  を悪化させるので避ける。
- 削除時の参照破壊（dangling reference）：削除通知や存在チェックを必ず行う。
- 早期最適化：まずはシンプルな Map
  ベースで具現化し、プロファイラで実際のボトルネックを特定してから最適化を行う。

## 13. トレードオフまとめ

- シンプル実装（Map）＝開発スピード↑、実行速度↓、メンテ容易
- 高速実装（Archetype/SoA）＝実行速度↑、実装複雑度↑、柔軟性↓
- 小〜中規模なら Map ベースで始めて、必要に応じてアーキタイプ移行が現実的

## 14. 推奨の出発点（実務上の指針）

- 小規模／プロトタイプ：Map ベース、コンポーネントは軽量なオブジェクト、System
  は同期的に update。
- 中〜大規模：アーキタイプ設計を検討。クエリ→アーキタイプキャッシュ→SoA
  へ段階的に移行。
- TypeScript：コンストラクタをキーにした Map
  ベースの実装で始め、必要なら型ユーティリティを追加。

## 15. 追加で用意できるもの（次の選択肢）

- Map ベースの TypeScript 実装例（教育向け、読みやすい）
- Archetype ベースの TypeScript 実装例（高性能、実装は複雑）
- クエリ/イベント/プーリング を備えた拡張 ECS サンプル
- Canvas / WebGL と統合したレンダリング例
